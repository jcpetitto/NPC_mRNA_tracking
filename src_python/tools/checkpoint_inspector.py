"""
checkpoint_inspector.py

Utilities for forensic analysis of pickled ImageProcessor objects.
Updated to handle Channel-Aware Status Ledgers.
"""

import pickle
import sys
import os
from pathlib import Path
import logging

# Ensure project root is in path to load ImageProcessor class
current_dir = Path(__file__).parent.resolve()
if str(current_dir) not in sys.path:
    sys.path.append(str(current_dir))

try:
    from image_processor import ImageProcessor
except ImportError:
    print("WARNING: Could not import ImageProcessor. Unpickling might fail.")

logging.basicConfig(level=logging.INFO, format='%(message)s')
logger = logging.getLogger(__name__)

def load_checkpoint(path):
    p = Path(path)
    if not p.exists():
        logger.error(f"File not found: {p}")
        return None
    try:
        with open(p, 'rb') as f:
            obj = pickle.load(f)
            logger.info(f"Loaded: {p.name}")
            return obj
    except Exception as e:
        logger.error(f"Failed to unpickle: {e}")
        return None

def list_pruned_nuclei(img_proc):
    """
    Lists all nuclei marked as PRUNED in the ledger, grouped by channel.
    """
    if not hasattr(img_proc, '_ne_status_ledger') or not img_proc._ne_status_ledger:
        logger.warning("No status ledger found.")
        return

    logger.info("\n=== PRUNED NUCLEI REPORT ===")
    
    total_pruned = 0
    
    # Iterate Channels (e.g., 'ch1', 'ch2')
    for channel, fov_dict in img_proc._ne_status_ledger.items():
        logger.info(f"\n--- Channel: {channel} ---")
        ch_pruned = 0
        
        for fov_id, ne_dict in fov_dict.items():
            for ne_label, info in ne_dict.items():
                if info.get('status') == 'PRUNED':
                    # Get reason from history
                    history = info.get('history', [])
                    reason_str = "N/A"
                    stage = "Unknown"
                    
                    if history:
                        last_event = history[-1]
                        stage = last_event.get('stage', 'Unknown')
                        metrics = last_event.get('metrics', {})
                        
                        # Format specific metrics if available
                        if stage == 'reg_stability':
                            val = metrics.get('mean_rdif', 0)
                            thresh = metrics.get('threshold', 0)
                            reason_str = f"Instability: {val:.3f}px > {thresh:.3f}px"
                        elif stage == 'refinement':
                            reason_str = "Refinement Failed"
                        else:
                            reason_str = str(metrics)

                    logger.info(f"  {fov_id} / {ne_label}: {stage} | {reason_str}")
                    ch_pruned += 1
        
        if ch_pruned == 0:
            logger.info("  No pruned nuclei.")
        else:
            logger.info(f"  Total {channel} Pruned: {ch_pruned}")
        total_pruned += ch_pruned

    logger.info(f"\nTotal Pruned (All Channels): {total_pruned}")

def inspect_lifecycle(img_proc, channel, fov_id, ne_label):
    """
    Deep dive into the history of a specific nucleus.
    """
    logger.info(f"\n=== LIFECYCLE: {channel} / {fov_id} / {ne_label} ===")
    
    ledger = getattr(img_proc, '_ne_status_ledger', {})
    
    if channel not in ledger or fov_id not in ledger[channel] or ne_label not in ledger[channel][fov_id]:
        logger.warning("  Not found in Ledger.")
        return

    info = ledger[channel][fov_id][ne_label]
    logger.info(f"Current Status: {info.get('status')}")
    logger.info(f"Last Stage: {info.get('last_stage')}")
    
    logger.info("History:")
    for event in info.get('history', []):
        ts = event['timestamp'].split('T')[1].split('.')[0] # Simple time
        logger.info(f"  [{ts}] {event['stage']} -> {event['status']}")
        if event.get('metrics'):
            logger.info(f"      Metrics: {event['metrics']}")

# --- Command Line Interface ---
if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python checkpoint_inspector.py <pkl_path> [channel] [fov_id] [ne_label]")
        sys.exit(1)
        
    path = sys.argv[1]
    img_proc = load_checkpoint(path)
    
    if img_proc:
        # Default action: List pruned
        list_pruned_nuclei(img_proc)
        
        # Optional: Inspect specific nucleus if args provided
        # Example: python checkpoint_inspector.py my.pkl ch1 0083 01
        if len(sys.argv) == 5:
            inspect_lifecycle(img_proc, sys.argv[2], sys.argv[3], sys.argv[4])


# """
# checkpoint_inspector.py

# A utility module for loading and inspecting pickled ImageProcessor objects 
# generated by the yeast imaging pipeline.

# Usage:
#     from checkpoint_inspector import load_and_inspect
#     img_proc = load_and_inspect("local_yeast_output/dual_label/checkpoints/BMY9999/state_after_bridging.pkl")
# """

# import pickle
# import sys
# import os
# from pathlib import Path
# import numpy as np
# import logging

# # Ensure the project root is in path so we can unpickle 'ImageProcessor'
# # (Pickle saves the class reference, so the class must be importable)
# current_dir = Path(__file__).parent.resolve()
# if str(current_dir) not in sys.path:
#     sys.path.append(str(current_dir))

# try:
#     from image_processor import ImageProcessor
# except ImportError:
#     print("WARNING: Could not import ImageProcessor. Unpickling might fail if classes are missing.")

# # Configure simple logging for inspection
# logging.basicConfig(level=logging.INFO, format='%(message)s')
# logger = logging.getLogger(__name__)

# def load_checkpoint(path):
#     """
#     Loads a pickled checkpoint file.
#     """
#     p = Path(path)
#     if not p.exists():
#         logger.error(f"File not found: {p}")
#         return None
    
#     try:
#         with open(p, 'rb') as f:
#             obj = pickle.load(f)
#             logger.info(f"Successfully loaded object of type: {type(obj).__name__}")
#             return obj
#     except Exception as e:
#         logger.error(f"Failed to unpickle: {e}")
#         return None

# def summarize_pipeline_stage(img_proc):
#     """
#     Prints a high-level summary of what data is present in the object.
#     """
#     if not isinstance(img_proc, ImageProcessor):
#         logger.warning("Object is not an ImageProcessor instance.")
#         return

#     logger.info("\n=== PIPELINE STATE SUMMARY ===")
    
#     # 1. FoVs
#     fovs = img_proc._get_FoV_collection_dict()
#     logger.info(f"FoVs Loaded: {len(fovs)}")
    
#     # 2. Registration
#     reg_mode1 = img_proc.get_registration_results(reg_mode=1)
#     logger.info(f"Registration (Mode 1): {'Present' if reg_mode1 else 'Empty'} ({len(reg_mode1)} FoVs)")
    
#     # 3. Initial Fit
#     ch1_init = img_proc._get_ch1_init_bsplines()
#     logger.info(f"Initial Splines (Ch1): {len(ch1_init) if ch1_init else 0} FoVs")
    
#     # 4. Refinement
#     ch1_ref = img_proc._get_ch1_refined_bsplines()
#     logger.info(f"Refined Splines (Ch1): {len(ch1_ref) if ch1_ref else 0} FoVs")
    
#     # 5. Bridging
#     ch1_bridge = img_proc._get_ch1_bridged_splines()
#     logger.info(f"Bridged Splines (Ch1): {len(ch1_bridge) if ch1_bridge else 0} FoVs")
    
#     # 6. Dual Label
#     dual_dists = img_proc.get_dual_distances_by_FoV()
#     logger.info(f"Dual Distances: {len(dual_dists) if dual_dists else 0} FoVs")
    
#     # 7. Status Ledger
#     if hasattr(img_proc, '_ne_status_ledger') and img_proc._ne_status_ledger:
#         # Count total tracked nuclei
#         total_tracked = sum(len(v) for v in img_proc._ne_status_ledger.values())
#         logger.info(f"Status Ledger: Tracking {total_tracked} nuclei across {len(img_proc._ne_status_ledger)} FoVs")
#     else:
#         logger.info("Status Ledger: Not present or empty")

# def inspect_fov_registration(img_proc, fov_id):
#     """
#     Drills down into the registration data for a specific FoV.
#     """
#     logger.info(f"\n--- Registration Audit: {fov_id} ---")
#     reg_data = img_proc.get_registration_results(reg_mode=1).get(fov_id)
    
#     if not reg_data:
#         logger.warning("No registration data found.")
#         return

#     # Global Stats
#     logger.info(f"Global Scale: {reg_data.get('scale', 'N/A')}")
#     logger.info(f"Global Shift: {reg_data.get('shift_vector', 'N/A')}")
    
#     # Calculated Precision (if present)
#     if 'ch_reg_prec' in reg_data:
#         logger.info(f"Pre-calculated Precision (ch_reg_prec): {reg_data['ch_reg_prec']:.4f}")
#     else:
#         logger.warning("Precision (ch_reg_prec) NOT found in data.")

#     # Slice Analysis
#     slices = [k for k in reg_data.keys() if k.startswith('slice_')]
#     if slices:
#         logger.info(f"Found {len(slices)} global time-slices.")
    
#     # NE Label Analysis
#     ne_keys = [k for k in reg_data.keys() if isinstance(reg_data[k], dict) and 'shift_vector' in reg_data[k]]
#     logger.info(f"NE Labels with local registration: {len(ne_keys)}")
#     if ne_keys:
#         sample_ne = ne_keys[0]
#         logger.info(f"Sample NE ({sample_ne}): {reg_data[sample_ne]['shift_vector']}")

# def inspect_ne_lifecycle(img_proc, fov_id, ne_label):
#     """
#     Traces a single nucleus through every stage of the pipeline.
#     """
#     logger.info(f"\n--- Lifecycle Trace: {fov_id} / {ne_label} ---")
    
#     # 1. Detection
#     init_splines = img_proc._get_ch1_init_bsplines().get(fov_id, {})
#     if ne_label in init_splines:
#         logger.info("[✓] Initial Detection: Present")
#     else:
#         logger.warning("[X] Initial Detection: MISSING")

#     # 2. Registration Stability
#     reg_data = img_proc.get_registration_results(reg_mode=1).get(fov_id, {})
#     if ne_label in reg_data:
#         logger.info("[✓] Registration: Present")
#         # Check slices
#         slices = [k for k in reg_data[ne_label].keys() if k.startswith('slice_')]
#         logger.info(f"    - Slices available: {len(slices)}")
#     else:
#         logger.warning("[X] Registration: MISSING (Pruned?)")

#     # 3. Refinement
#     ref_splines = img_proc._get_ch1_refined_bsplines().get(fov_id, {})
#     if ne_label in ref_splines:
#         segments = ref_splines[ne_label]
#         logger.info(f"[✓] Refinement: Present ({len(segments)} segments)")
#     else:
#         logger.warning("[X] Refinement: MISSING (Pruned or Failed)")

#     # 4. Bridging
#     bridge_data = img_proc._get_ch1_bridged_splines().get(fov_id, {})
#     if ne_label in bridge_data:
#         data = bridge_data[ne_label]
#         logger.info("[✓] Bridging: Present")
#         logger.info(f"    - Data Segments: {len(data.get('data_segments', []))}")
#         logger.info(f"    - Bridges: {len(data.get('bridge_segments', []))}")
#     else:
#         logger.warning("[X] Bridging: MISSING")

#     # 5. Status Ledger History
#     if hasattr(img_proc, '_ne_status_ledger'):
#         history = img_proc._ne_status_ledger.get(fov_id, {}).get(ne_label, {}).get('history', [])
#         if history:
#             logger.info("--- Status Ledger History ---")
#             for entry in history:
#                 logger.info(f"  {entry['timestamp']} | {entry['stage']} -> {entry['status']}")
#                 if entry.get('metrics'):
#                     logger.info(f"    Metrics: {entry['metrics']}")

# def list_pruned_nuclei(img_proc):
#     """
#     Lists all nuclei currently marked as PRUNED in the ledger.
#     """
#     if not hasattr(img_proc, '_ne_status_ledger') or not img_proc._ne_status_ledger:
#         logger.warning("No status ledger found.")
#         return

#     logger.info("\n--- Pruned Nuclei Report ---")
#     count = 0
#     for fov_id, ne_dict in img_proc._ne_status_ledger.items():
#         for ne_label, info in ne_dict.items():
#             if info.get('status') == 'PRUNED':
#                 last_event = info['history'][-1]
#                 reason = last_event.get('metrics', 'N/A')
#                 stage = last_event.get('stage', 'Unknown')
#                 logger.info(f"{fov_id}/{ne_label}: {stage} | {reason}")
#                 count += 1
    
#     if count == 0:
#         logger.info("No nuclei marked as PRUNED.")
#     else:
#         logger.info(f"Total Pruned: {count}")

# # --- Interactive Helper ---
# if __name__ == "__main__":
#     if len(sys.argv) > 1:
#         path = sys.argv[1]
#     else:
#         print("Usage: python checkpoint_inspector.py <path_to_pkl>")
#         # Default for testing
#         path = "local_yeast_output/dual_label/checkpoints/BMY9999/state_after_bridging.pkl"
    
#     print(f"Loading: {path} ...")
#     img_proc = load_checkpoint(path)
    
#     if img_proc:
#         summarize_pipeline_stage(img_proc)
        
#         # Example: List pruned items
#         list_pruned_nuclei(img_proc)
        
#         # Example: Deep dive into first FoV found
#         first_fov = list(img_proc._get_ch1_init_bsplines().keys())[0]
#         inspect_fov_registration(img_proc, first_fov)