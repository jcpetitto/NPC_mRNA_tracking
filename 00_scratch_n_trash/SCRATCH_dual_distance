from utils.ne_dual_labels import calc_dual_distances
import json
import pickle

# Load the bridged initial splines you just created
with open('local_yeast_output/dual_label/merged_splines/bridged_initial_ch1.pkl', 'rb') as f:
    bridged_init_ch1 = pickle.load(f)
with open('local_yeast_output/dual_label/merged_splines/bridged_initial_ch2.pkl', 'rb') as f:
    bridged_init_ch2 = pickle.load(f)

# Load config and NE pairs
with open('config_local_dual.json', 'r') as f:
    config = json.load(f)

# Get NE pairs from your image processor or load from saved file
# (You'll need to load this from wherever you saved it)
from imaging_pipeline import ImagingPipeline
pipeline = ImagingPipeline("config_local_dual.json")
# Assuming you have img_proc loaded or can recreate it
# ne_pairs = img_proc.get_ne_pairs_by_FoV()

# Or load from checkpoint if available
with open('local_yeast_output/dual_label/checkpoints/BMY9999_99_99_9999/state_after_filtering.pkl', 'rb') as f:
    img_proc = pickle.load(f)
    ne_pairs = img_proc.get_ne_pairs_by_FoV()

# Calculate distances!
distances = calc_dual_distances(
    FoV_dict=pipeline.get_experiments()['BMY9999_99_99_9999'],
    ch1_bsplines=bridged_init_ch1,
    ch2_bsplines=bridged_init_ch2,
    ne_pairs_map=ne_pairs,
    ch1_key='fn_track_ch1',
    ch2_key='fn_track_ch2',
    min_iou=0.9,
    N_dist_calc=200,
    pixel_size_nm=128
)

# Save results
with open('local_yeast_output/dual_label/distances/distances_from_initial_splines.json', 'w') as f:
    json.dump(distances, f, indent=2)

print(f"Calculated distances for {len(distances)} FoVs")
for fov_id, pairs in distances.items():
    for pair_key, stats in pairs.items():
        print(f"{fov_id}/{pair_key}: Mean = {stats['mean_distance']:.2f} nm, Std = {stats['std_distance']:.2f} nm")